#!/usr/bin/env python3
import os, subprocess, sys, time, signal, argparse
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path

try:
    from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeRemainingColumn
    from rich.console import Console
except ImportError:
    print("Error: 'rich' library missing. Run: pip install rich --break-system-packages")
    sys.exit(1)

DEFAULT_PATH = "/mnt/synology/Keithens folder/OBS Output"
FFMPEG_CMD = ["ffmpeg", "-y", "-i", "{input}", "-c:v", "dnxhd", "-profile:v", "dnxhr_lb", "-pix_fmt", "yuv422p", "-c:a", "pcm_s16le", "-f", "mov", "{output}"]
console = Console()
running_processes = []

def get_duration(file_path):
    cmd = ["ffprobe", "-v", "error", "-show_entries", "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", str(file_path)]
    result = subprocess.run(cmd, capture_output=True, text=True)
    try: return float(result.stdout.strip())
    except: return 0

def process_video(video_path, progress, task_id, quick_mode, delete_source):
    output_dir = video_path.parent / "Done"
    output_dir.mkdir(exist_ok=True)
    output_path = output_dir / f"{video_path.stem}.mov"
    source_dur = get_duration(video_path)
    if output_path.exists():
        if quick_mode or abs(get_duration(output_path) - source_dur) < 2.0:
            progress.update(task_id, description=f"[bold green]Done: {video_path.name}", completed=source_dur)
            if delete_source: os.remove(video_path)
            return
    cmd = [c.format(input=str(video_path), output=str(output_path)) for c in FFMPEG_CMD] + ["-progress", "pipe:1", "-nostats"]
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
    running_processes.append((proc, output_path))
    while True:
        line = proc.stdout.readline()
        if not line and proc.poll() is not None: break
        if "out_time_ms=" in line:
            try: progress.update(task_id, completed=(int(line.split("out_time_ms=")[1].strip()) / 1_000_000))
            except: pass
    if proc.returncode == 0:
        progress.update(task_id, description=f"[bold green]Success: {video_path.name}")
        if delete_source: os.remove(video_path)
    else: progress.update(task_id, description=f"[bold red]FAILED: {video_path.name}")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--path"); parser.add_argument("--quick", action="store_true"); parser.add_argument("--delete", action="store_true"); parser.add_argument("--overnight", action="store_true")
    args = parser.parse_args()
    if not args.path:
        p_in = input(f"Path (or 'c'): ").strip()
        path, quick, delete, overnight = (DEFAULT_PATH if p_in.lower()=='c' else p_in), input("Quick? (y/n): ")=='y', input("Delete? (y/n): ")=='y', input("Overnight? (y/n): ")=='y'
    else: path, quick, delete, overnight = args.path, args.quick, args.delete, args.overnight
    files = [f for f in Path(path).glob('*') if f.suffix.lower() in ['.mp4', '.mkv', '.mov'] and f.parent.name != "Done"]
    with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"), BarColumn(), TimeRemainingColumn(), console=console) as progress:
        with ThreadPoolExecutor(max_workers=4) as executor:
            for f in files:
                tid = progress.add_task(f"[white]{f.name}", total=get_duration(f) if not quick else 100)
                executor.submit(process_video, f, progress, tid, quick, delete)
    if overnight: os.system("sudo shutdown now")

if __name__ == "__main__": main()
